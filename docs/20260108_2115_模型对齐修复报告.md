> 生成时间: 2026-01-08 21:15

# LS-NTGF-All 模型对齐修复报告

**文档版本**: 1.0
**修复日期**: 2026-01-08
**作者**: Claude Code

---

## 1. 概述

本报告详细记录了 LS-NTGF-All 项目中发现的 4 个关键模型对齐问题及其修复过程。这些问题导致代码实现与 PDF 规范文档中的数学模型存在语义偏差。

### 1.1 问题清单

| 编号 | 问题类型 | 严重程度 | 状态 |
|------|----------|----------|------|
| (A) | 交货期约束处理 | 高 | 已修复 |
| (B) | 初始条件索引 | 高 | 已修复 |
| (C) | 欠交与未满足惩罚系数 | 中 | 已修复 |
| (RR) | 阶段1产能缩放 | 中 | 已修复 |

---

## 2. 问题详细分析

### 2.1 问题(A): 交货期约束处理

#### 2.1.1 PDF 规范语义

根据 PDF 文档，时间窗口约束定义如下：

- $e_i$: 订单 $i$ 的最早生产期（Earliest production period）
- $l_i$: 订单 $i$ 的交货期（Due date）

约束要求：
- **约束(13)**: $x_{it} = 0, \quad \forall i, t < e_i$ （最早期之前禁止生产）
- 交货期 $l_i$ **不是**生产的硬性截止日期

欠交变量 $b_{it}$ 的语义：
- 仅在 $t \geq l_i$ 时有意义（交货期及之后才计算欠交）
- 目标函数中欠交惩罚项：$\sum_{i} \sum_{t \geq l_i} c^B_i \cdot b_{it}$

#### 2.1.2 原代码问题

原代码错误地将 $l_i$ 视为生产的硬性截止日期：

```cpp
// 错误实现 - 禁止交货期后生产
for (int i = 0; i < values.number_of_items; ++i) {
    for (int t = 0; t < values.number_of_periods; ++t) {
        if (t < lists.ew_x[i] || t > lists.lw_x[i]) {  // 错误: t > l_i 也被禁止
            model.add(X[i][t] == 0);
        }
    }
}
```

**问题影响**：
- 完全禁止交货期后的生产，导致部分可行解被排除
- 与欠交惩罚机制的设计意图矛盾
- 可能导致本应通过延迟生产+欠交惩罚解决的问题变成无解

#### 2.1.3 修复方案

仅约束最早生产期，交货期后的生产通过欠交惩罚控制：

```cpp
// 正确实现 - 仅约束最早期
// 约束(13): 最早生产期约束 (仅约束 t < e_i)
// 注意: t > l_i 后仍可生产，通过欠交惩罚控制
for (int i = 0; i < values.number_of_items; ++i) {
    for (int t = 0; t < values.number_of_periods; ++t) {
        if (t < lists.ew_x[i]) {
            model.add(X[i][t] == 0);
        }
    }
}
```

---

### 2.2 问题(B): 初始条件索引

#### 2.2.1 PDF 规范语义

初始条件约束：

- **约束(10)**: $\lambda_{g0} = 0, \quad \forall g$ （第一周期无跨期，因为没有前序周期）
- **注意**: $y_{g0}$ **不应**被强制为 0，第一周期允许启动生产

跨期变量 $\lambda_{gt}$ 的含义：
- $\lambda_{gt} = 1$ 表示产品组 $g$ 在周期 $t$ 从上一周期继续生产（跨期）
- 第一周期 $t=0$ 没有"上一周期"，因此 $\lambda_{g0} = 0$ 是自然的边界条件

#### 2.2.2 原代码问题

原代码错误地同时强制 $y_{g0} = 0$：

```cpp
// 错误实现 - 同时约束 Y 和 Lambda
for (int g = 0; g < values.number_of_groups; ++g) {
    model.add(Y[g][0] == 0);      // 错误: 禁止第一周期启动
    model.add(Lambda[g][0] == 0); // 正确: 第一周期无跨期
}
```

**问题影响**：
- 完全禁止第一周期的生产启动
- 如果某些订单的最早生产期 $e_i = 0$，则这些订单在第一周期无法生产
- 可能导致不必要的库存积压或需求无法满足

#### 2.2.3 修复方案

仅约束 $\lambda_{g0} = 0$，允许 $y_{g0}$ 自由决策：

```cpp
// 正确实现 - 仅约束 Lambda
// 约束(10): 初始状态 - lambda_g0 = 0 (第一周期无跨期，因为没有前序周期)
// 注意: Y[g][0] 不约束为0，第一周期允许启动
for (int g = 0; g < values.number_of_groups; ++g) {
    model.add(Lambda[g][0] == 0);
}
```

---

### 2.3 问题(C): 欠交与未满足惩罚系数

#### 2.3.1 PDF 规范语义

惩罚系数定义：

- $c^B_i$: 订单 $i$ 的单位欠交惩罚（Order-specific backorder penalty）
- $c^U_i$: 订单 $i$ 的未满足惩罚（Order-specific unmet penalty）

目标函数中的惩罚项：
$$\sum_{i} \sum_{t \geq l_i} c^B_i \cdot b_{it} + \sum_{i} c^U_i \cdot u_i$$

**关键点**: 惩罚系数是**订单特定的**（order-specific），不同订单可以有不同的惩罚权重。

#### 2.3.2 原代码问题

原代码使用全局惩罚系数：

```cpp
// 错误实现 - 使用全局惩罚
for (int i = 0; i < N; i++) {
    for (int t = 0; t < T; t++) {
        objective += values.b_penalty * B[i][t];  // 错误: 全局系数
    }
    objective += values.u_penalty * U[i];         // 错误: 全局系数
}
```

**问题影响**：
- 无法区分不同订单的优先级
- 所有订单使用相同的惩罚权重，无法反映实际业务中订单的差异化重要性
- 限制了模型的灵活性和实用性

#### 2.3.3 修复方案

**步骤1**: 在数据结构中添加订单特定惩罚数组

```cpp
// optimizer.h - AllLists 结构体
struct AllLists {
    // ... 其他成员 ...

    // 成本参数
    vector<double> cost_x;
    vector<int> cost_y;
    vector<double> cost_i;
    vector<double> cost_b;  // cB[i]: 订单i的单位欠交惩罚
    vector<double> cost_u;  // cU[i]: 订单i的未满足惩罚

    // ... 其他成员 ...
};
```

**步骤2**: 在数据读取时初始化（使用全局默认值）

```cpp
// input.cpp
// 初始化订单特定惩罚系数 (使用全局默认值)
lists.cost_b.resize(values.number_of_items, values.b_penalty);
lists.cost_u.resize(values.number_of_items, values.u_penalty);
```

**步骤3**: 目标函数使用订单特定系数

```cpp
// 正确实现 - 使用订单特定惩罚
// 欠交惩罚 (仅 t >= l_i)
for (int i = 0; i < N; i++) {
    for (int t = lists.lw_x[i]; t < T; t++) {
        objective += lists.cost_b[i] * B[i][t];
    }
}

// 未满足惩罚
for (int i = 0; i < N; i++) {
    objective += lists.cost_u[i] * U[i];
}
```

---

### 2.4 问题(RR): 阶段1产能缩放

#### 2.4.1 PDF 规范语义

Relax-and-Recover (RR) 算法的三阶段设计：

**阶段1 (Relaxed Capacity)**:
- 目的: 确定最优的启动结构 $y^*$
- 方法: 放大产能约束，使产能不再是瓶颈
- 产能约束: $\sum_i a_i x_{it} \leq \alpha \cdot C_t$，其中 $\alpha >> 1$

**阶段2 (Setup Carryover)**:
- 目的: 基于 $y^*$ 确定跨期结构 $\lambda^*$
- 固定 $y = y^*$，求解 $\lambda$

**阶段3 (Final Recovery)**:
- 目的: 在真实产能下求解最终方案
- 固定 $y = y^*$, $\lambda = \lambda^*$，恢复原始产能约束

#### 2.4.2 原代码问题

原代码的产能放大系数设为 1.0（即不放大）：

```cpp
// 错误实现 - 产能未放大
const double kCapacityExpansionFactor = 1.0;  // Stage 1 产能放大系数 (1.0 = 不放大)
```

**问题影响**：
- 阶段1与原问题完全相同，无法达到"放松产能"的目的
- 启动结构 $y^*$ 可能因为产能限制而不是最优的"理想"结构
- RR 算法退化为普通的固定变量求解，失去了分解算法的优势

#### 2.4.3 修复方案

将产能放大系数设为较大值（如 10.0）：

```cpp
// 正确实现 - 产能显著放大
const double kCapacityExpansionFactor = 10.0;  // Stage 1 产能放大系数 (alpha >> 1)
```

---

## 3. 修改文件清单

### 3.1 核心头文件

| 文件 | 修改内容 |
|------|----------|
| `src/optimizer.h` | 添加 `cost_b`, `cost_u` 向量到 `AllLists` 结构体 |

### 3.2 数据输入

| 文件 | 修改内容 |
|------|----------|
| `src/input.cpp` | 初始化 `cost_b`, `cost_u` 数组 |

### 3.3 求解器文件

| 文件 | 修改内容 |
|------|----------|
| `src/cplex_lot_sizing.cpp` | (A) 时间窗口约束, (B) 初始条件, (C) 惩罚系数 |
| `src/solvers/rf_solver.cpp` | (A) 时间窗口约束, (B) 初始条件, (C) 惩罚系数 |
| `src/solvers/rfo_solver.cpp` | (A) 时间窗口约束, (B) 初始条件, (C) 惩罚系数 |
| `src/solvers/rr_solver.cpp` | (A) 时间窗口约束, (B) 初始条件, (C) 惩罚系数, (RR) 产能缩放 |
| `src/big_order.cpp` | (C) 惩罚系数 |

---

## 4. 修改详情

### 4.1 问题(A) 修改位置

**cplex_lot_sizing.cpp** (约第140行):
```cpp
// 修改前
if (t < lists.ew_x[i] || t > lists.lw_x[i]) {
    model.add(X[i][t] == 0);
}

// 修改后
if (t < lists.ew_x[i]) {
    model.add(X[i][t] == 0);
}
```

**rf_solver.cpp**, **rfo_solver.cpp**, **rr_solver.cpp** 中的相同模式均已修改。

### 4.2 问题(B) 修改位置

**cplex_lot_sizing.cpp** (约第130行):
```cpp
// 修改前
for (int g = 0; g < values.number_of_groups; ++g) {
    model.add(Y[g][0] == 0);
    model.add(Lambda[g][0] == 0);
}

// 修改后
for (int g = 0; g < values.number_of_groups; ++g) {
    model.add(Lambda[g][0] == 0);
}
```

### 4.3 问题(C) 修改位置

**optimizer.h** (AllLists 结构体):
```cpp
vector<double> cost_b;  // cB[i]: 订单i的单位欠交惩罚
vector<double> cost_u;  // cU[i]: 订单i的未满足惩罚
```

**input.cpp** (ReadData 函数末尾):
```cpp
lists.cost_b.resize(values.number_of_items, values.b_penalty);
lists.cost_u.resize(values.number_of_items, values.u_penalty);
```

**所有求解器的目标函数**:
```cpp
// 修改前
objective += values.b_penalty * B[i][t];
objective += values.u_penalty * U[i];

// 修改后
objective += lists.cost_b[i] * B[i][t];
objective += lists.cost_u[i] * U[i];
```

### 4.4 问题(RR) 修改位置

**rr_solver.cpp** (第11行):
```cpp
// 修改前
const double kCapacityExpansionFactor = 1.0;

// 修改后
const double kCapacityExpansionFactor = 10.0;
```

---

## 5. 验证测试

### 5.1 编译测试

```
cmake --build build/release --config Release
```

**结果**: 编译成功，无错误或警告。

### 5.2 功能测试

使用 RF 算法测试：
```
LS-NTGF-All.exe --algo=RF -t 10 60_N100_T30_F5_G5_1_20260105_222608.csv
```

**结果**:
- 求解成功
- 目标值: 1,008,201.00
- 运行时间: 约 8 秒
- 所有 30 个子问题均成功求解

---

## 6. 后续建议

### 6.1 扩展性改进

1. **CSV 数据格式扩展**: 考虑在输入文件中支持订单特定的 $c^B_i$ 和 $c^U_i$ 值，而不仅仅使用全局默认值。

2. **产能缩放参数化**: 将 `kCapacityExpansionFactor` 改为可配置参数，允许用户根据问题规模调整。

### 6.2 文档维护

1. 更新 PDF 规范文档，明确上述语义细节
2. 在代码注释中保持与 PDF 公式编号的对应关系

---

## 7. 附录: 修改前后对比

### 7.1 目标函数结构对比

**修改前** (以 RF 为例):
```cpp
IloExpr objective(env);
for (int i = 0; i < N; i++) {
    for (int t = 0; t < T; t++) {
        objective += lists.cost_x[i] * X[i][t];
        objective += values.b_penalty * B[i][t];  // 全局系数，所有周期
    }
}
// ... 启动成本、库存成本 ...
for (int i = 0; i < N; i++) {
    objective += values.u_penalty * U[i];  // 全局系数
}
```

**修改后**:
```cpp
IloExpr objective(env);
// 生产成本
for (int i = 0; i < N; i++) {
    for (int t = 0; t < T; t++) {
        objective += lists.cost_x[i] * X[i][t];
    }
}
// 欠交惩罚 (仅 t >= l_i)
for (int i = 0; i < N; i++) {
    for (int t = lists.lw_x[i]; t < T; t++) {
        objective += lists.cost_b[i] * B[i][t];  // 订单特定系数
    }
}
// ... 启动成本、库存成本 ...
// 未满足惩罚
for (int i = 0; i < N; i++) {
    objective += lists.cost_u[i] * U[i];  // 订单特定系数
}
```

---

**文档结束**
