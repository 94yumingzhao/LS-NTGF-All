# RR 算法跨期机制问题分析报告

**日期**: 2026-01-09
**分析对象**: LS-NTGF-All RR 算法
**问题现象**: 阶段2发现0个跨期机会，跨期优化完全失效

---

## 一、问题现象

### 1.1 日志摘要

| 阶段 | 耗时 | 目标值 | 关键输出 |
|------|------|--------|----------|
| 阶段1 | 600.32s | 343,891.71 | 15个启动，Gap 0.09% |
| 阶段2 | 0.04s | 0.00 | **发现 0 个跨期机会** |
| 阶段3 | 2.16s | 17,435,212.17 | 使用 0 个跨期 |

### 1.2 阶段2的 CPLEX 输出

```
Found incumbent of value 0.000000 after 0.00 sec.
MIP Presolve eliminated 470 rows and 300 columns.
All rows and columns eliminated.
```

CPLEX 预处理直接消除了所有变量，说明在给定约束下，所有决策变量只有唯一可行值 0。

### 1.3 最终结果影响

```json
{
  "total_carryovers": 0,
  "saved_setup_cost": 0.00,
  "unmet_rate": 0.5167,
  "backorder": 15674200.00
}
```

跨期机制完全失效，51.67% 的订单未满足。

---

## 二、问题原因分析

### 2.1 阶段1产生的启动结构

从结果文件中提取的 Y 矩阵（启动决策）：

```
G1: t=5,  11, 21, 25  (间隔: 6, 10, 4 个周期)
G2: t=3,  8,  18, 29  (间隔: 5, 10, 11 个周期)
G3: t=1,  7,  17, 28  (间隔: 6, 10, 11 个周期)
G4: t=2,  15          (间隔: 13 个周期)
G5: t=16              (仅 1 个启动)
```

**关键发现：所有5个族都没有连续两个周期启动的情况。**

### 2.2 阶段2的跨期约束

代码位置: `src/solvers/rr_solver.cpp` 第 326-331 行

```cpp
// 约束 (b): Carryover 只能在连续激活的周期间发生
for (int g = 0; g < values.number_of_groups; ++g) {
    for (int t = 1; t < values.number_of_periods; ++t) {
        model.add(2 * Lambda[g][t] <= Y[g][t - 1] + Y[g][t]);
    }
}
```

**数学含义**:

$$2\lambda_{g,t} \leq y_{g,t-1} + y_{g,t}$$

若要 $\lambda_{g,t} = 1$（启用跨期），则必须：
- $y_{g,t-1} = 1$（第 t-1 周期启动）
- $y_{g,t} = 1$（第 t 周期也启动）

**由于阶段1没有产生任何连续启动，所有 λ 只能为 0。**

### 2.3 阶段1启动稀疏的原因

阶段1使用了产能放大策略：

```cpp
// src/solvers/rr_solver.cpp 第 11 行
const double kCapacityExpansionFactor = 10.0;

// 第 86-98 行
double capacity_big = values.machine_capacity * kCapacityExpansionFactor;
```

产能放大 10 倍后：
- 每个周期可生产大量产品
- 算法倾向于集中在少数周期启动，减少启动成本
- 启动之间的间隔变大，不再相邻

### 2.4 问题的本质

```
阶段1策略          阶段2约束条件
    |                   |
    v                   v
产能放大10倍   -->   启动稀疏   -->   无连续启动
                                         |
                                         v
                          跨期约束 2λ ≤ y_{t-1} + y_t
                                         |
                                         v
                                   所有 λ = 0
                                         |
                                         v
                                  阶段2完全失效
```

**核心矛盾**：阶段1的松弛策略与阶段2的跨期条件在设计上不兼容。

---

## 三、问题性质判定

### 3.1 这是数学建模问题，非程序实现错误

| 检查项 | 结论 |
|--------|------|
| 程序是否正确实现数学模型 | 是 |
| 数学模型是否存在逻辑缺陷 | **是** |
| 参数设置是否合理 | 需要调整 |

### 3.2 各阶段状态

| 阶段 | 代码实现 | 数学模型 | 参数设置 |
|------|----------|----------|----------|
| 阶段1 | 正确 | 合理 | **产能放大系数过大** |
| 阶段2 | 正确 | **与阶段1不兼容** | N/A |
| 阶段3 | 正确 | 合理 | 依赖阶段2结果 |

---

## 四、修复方案

### 方案1：降低产能放大系数（最简单）

**修改位置**: `src/solvers/rr_solver.cpp` 第 11 行

```cpp
// 当前
const double kCapacityExpansionFactor = 10.0;

// 建议改为
const double kCapacityExpansionFactor = 2.0;  // 或 3.0
```

**原理**：降低产能放大系数，迫使算法在更多周期启动，增加连续启动的可能性。

**优点**：修改简单，风险低
**缺点**：不能保证一定产生连续启动

---

### 方案2：在阶段1添加连续启动激励

**修改位置**: `src/solvers/rr_solver.cpp` 阶段1目标函数

```cpp
// 原始目标函数
IloExpr objective = 生产成本 + 启动成本 + 库存成本 + ...;

// 添加连续启动奖励项
double consecutive_bonus = -0.1 * 平均启动成本;  // 负值作为奖励
for (int g = 0; g < G; ++g) {
    for (int t = 1; t < T; ++t) {
        // Y[g][t-1] * Y[g][t] 只有在两者都为1时才为1
        objective += consecutive_bonus * Y[g][t-1] * Y[g][t];
    }
}
```

**注意**：这会引入二次项，需要线性化处理：

```cpp
// 引入辅助变量 Z[g][t] = Y[g][t-1] * Y[g][t]
IloArray<IloNumVarArray> Z(env, G);
for (int g = 0; g < G; ++g) {
    Z[g] = IloNumVarArray(env, T, 0, 1, ILOBOOL);
}

// 线性化约束
for (int g = 0; g < G; ++g) {
    for (int t = 1; t < T; ++t) {
        model.add(Z[g][t] <= Y[g][t-1]);
        model.add(Z[g][t] <= Y[g][t]);
        model.add(Z[g][t] >= Y[g][t-1] + Y[g][t] - 1);
    }
}

// 目标函数使用 Z
objective += consecutive_bonus * IloSum(Z);
```

**优点**：主动引导产生连续启动
**缺点**：增加模型复杂度，可能影响求解性能

---

### 方案3：放宽阶段2跨期条件

**修改位置**: `src/solvers/rr_solver.cpp` 阶段2约束

```cpp
// 当前约束：要求严格相邻
model.add(2 * Lambda[g][t] <= Y[g][t - 1] + Y[g][t]);

// 方案3a：允许间隔1个周期（"软跨期"）
if (t >= 2) {
    model.add(Lambda[g][t] <= Y[g][t-1] + Y[g][t] + Y[g][t-2]);
}

// 方案3b：使用更宽松的条件
// 只要前后k个周期内有启动即可
int k = 2;
IloExpr nearby_setups(env);
for (int dt = -k; dt <= k; ++dt) {
    if (t + dt >= 0 && t + dt < T) {
        nearby_setups += Y[g][t + dt];
    }
}
model.add(Lambda[g][t] * 2 <= nearby_setups);
```

**优点**：直接解决约束过严的问题
**缺点**：可能偏离原始算法设计意图

---

### 方案4：两阶段迭代策略

**思路**：阶段1求解后检查启动结构，若无连续启动则调整参数重新求解。

```cpp
bool has_consecutive = false;
int max_iterations = 3;
double expansion_factor = 10.0;

for (int iter = 0; iter < max_iterations && !has_consecutive; ++iter) {
    // 使用当前 expansion_factor 求解阶段1
    SolveStep1(values, lists, expansion_factor);

    // 检查是否存在连续启动
    for (int g = 0; g < G && !has_consecutive; ++g) {
        for (int t = 1; t < T; ++t) {
            if (lists.small_y[g][t-1] == 1 && lists.small_y[g][t] == 1) {
                has_consecutive = true;
                break;
            }
        }
    }

    if (!has_consecutive) {
        expansion_factor *= 0.5;  // 减半产能放大系数
        LOG_FMT("未发现连续启动，降低系数到 %.1f 重试\n", expansion_factor);
    }
}
```

**优点**：自适应调整，保证跨期机制有效
**缺点**：增加求解时间

---

### 方案5：强制连续启动约束

**修改位置**: 阶段1添加硬约束

```cpp
// 每个族至少有一组连续启动
for (int g = 0; g < G; ++g) {
    IloExpr consecutive_sum(env);
    for (int t = 1; t < T; ++t) {
        // 需要线性化 Y[g][t-1] * Y[g][t]
        consecutive_sum += Z[g][t];  // Z[g][t] 是辅助变量
    }
    model.add(consecutive_sum >= 1);  // 至少一组连续启动
}
```

**优点**：保证阶段2有机会找到跨期
**缺点**：可能导致阶段1无可行解或解质量下降

---

## 五、方案对比

| 方案 | 实现难度 | 风险 | 效果可靠性 | 推荐优先级 |
|------|----------|------|------------|------------|
| 方案1：降低系数 | 低 | 低 | 中 | 1 (先尝试) |
| 方案2：连续激励 | 中 | 中 | 高 | 2 |
| 方案4：迭代策略 | 中 | 低 | 高 | 3 |
| 方案3：放宽条件 | 低 | 中 | 中 | 4 |
| 方案5：强制约束 | 中 | 高 | 高 | 5 (谨慎) |

---

## 六、结论

1. **问题性质**：数学建模层面的设计缺陷，非程序 bug

2. **根本原因**：阶段1的产能放大策略与阶段2的连续启动要求存在内在矛盾

3. **推荐修复路径**：
   - 首先尝试方案1（降低产能放大系数到 2-3）
   - 若效果不佳，实施方案2（添加连续启动激励）
   - 可选实施方案4（迭代策略）作为保障机制

4. **预期效果**：修复后阶段2应能发现跨期机会，从而在阶段3中节省启动成本，降低总目标值
