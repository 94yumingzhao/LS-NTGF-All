# PP-GCB生产计划模型数值实验方案

## 1. 研究背景

### 1.1 研究意义

镀锌钢板通过在表面涂覆金属锌层来防止腐蚀、延长产品使用寿命。由于其优异的机械性能和卓越的耐腐蚀性，镀锌钢板被广泛应用于建筑、汽车和各类制造业中。为满足日益增长的市场需求并保持竞争力，钢铁制造商不断寻求有效策略来提高生产效率、降低运营成本，而高效的生产计划是实现这些目标的关键。

### 1.2 生产流程

镀锌钢板在镀锌生产线上根据客户订单或下游工序需求进行生产。生产流程包括：

1. **订单接收**：每个订单具有需求量、就绪时间（ready time，最早开始时间）和交货期（due date，最晚完成时间）
2. **物料准备**：来自上游冷轧线的冷轧卷材被分配给各订单
3. **镀锌处理**：钢带通过含有熔融镀锌材料的镀锌槽进行涂覆
4. **Setup（启动）**：切换镀锌材料需要排空、清洗和重新熔化，造成大量停机时间

### 1.3 关键概念

| 概念 | 英文术语 | 说明 |
|------|----------|------|
| **时间窗口** | Time Window | 订单的就绪时间与交货期之间的时间段，理想情况下应在此期间完成生产 |
| **订单族/组** | Order Family / Group | 需要相同镀锌材料的订单集合，可连续加工无需setup |
| **Setup Carryover** | Setup Carryover | 上一周期的setup状态延续到下一周期，减少启动时间和成本 |
| **欠交/积压** | Backlogging | 允许在交货期后生产，但会产生惩罚成本 |

---

## 2. 问题描述

### 2.1 问题概述

生产计划问题旨在生成最优生产计划，在规定的计划期内高效满足客户订单和下游工序需求。PP-GCB（Production Planning with Grouping, Carryover, and Backlogging）模型综合考虑了生产计划中的实际复杂性。

### 2.2 集合与下标

| 符号 | 说明 |
|------|------|
| N | 所有订单的集合，下标为 i |
| T | 时间周期集合，下标为 t |
| F | 下游工序（Flow）集合，下标为 f |
| G | 订单族（Group）集合，下标为 g |

### 2.3 参数定义

| 符号 | 说明 |
|------|------|
| d_i | 订单 i 的总需求量 |
| e_i | 订单 i 的最早允许生产时间（就绪时间） |
| l_i | 订单 i 的交货期（最晚完成时间） |
| d_ft | 下游工序 f 在周期 t 的需求量 |
| C_t | 周期 t 的最大生产产能 |
| D_ft | 下游工序 f 在周期 t 的加工能力 |
| c_i^X | 订单 i 的单位生产成本 |
| c_g^Y | 订单族 g 的setup成本 |
| c_f^I | 下游工序 f 的单位库存持有成本 |
| c_i^U | 订单 i 需求未满足时的惩罚成本 |
| c_i^B | 订单 i 交货期后每单位未满足需求每单位时间的惩罚成本 |
| s_i^X | 订单 i 单位生产量的产能占用 |
| s_g^Y | 订单族 g setup的产能占用 |
| h_ig | 二元参数：订单 i 属于订单族 g 时为1，否则为0 |
| k_if | 二元参数：订单 i 可满足下游工序 f 时为1，否则为0 |

### 2.4 决策变量

| 变量 | 类型 | 说明 |
|------|------|------|
| x_it | 连续变量 | 订单 i 在周期 t 的生产量 |
| y_gt | 二元变量 | 周期 t 是否对订单族 g 进行setup（1=是） |
| I_ft | 连续变量 | 下游工序 f 在周期 t 末的库存水平 |
| lambda_gt | 二元变量 | 订单族 g 的setup是否从 t-1 carryover到 t（1=是） |
| u_i | 二元变量 | 订单 i 的需求是否未满足（1=是） |
| b_it | 连续变量 | 订单 i 在周期 t 末的未满足需求量（t >= l_i） |
| P_ft | 连续变量 | 下游工序 f 在周期 t 的加工量 |

### 2.5 数学模型

**目标函数：**

最小化总成本，包括生产成本、欠交惩罚、setup成本、库存成本和未满足需求惩罚：

```
min  SUM_{i in N, t in T} c_i^X * x_it           // 生产成本
   + SUM_{i in N, t=l_i}^T c_i^B * b_it          // 欠交惩罚
   + SUM_{g in G, t in T} c_g^Y * y_gt           // setup成本
   + SUM_{f in F, t in T} c_f^I * I_ft           // 库存成本
   + SUM_{i in N} c_i^U * u_i                    // 未满足需求惩罚
```

**约束条件：**

**(2) 流量平衡约束：**
```
SUM_{i in N} k_if * x_it + I_{f,t-1} - P_ft - I_ft = 0,  对所有 f in F, t in T
```
说明：确保生产量与库存水平在各工序间匹配。

**(3) 加工能力约束：**
```
P_ft <= D_ft,  对所有 f in F, t in T
```
说明：限制生产量不超过各工序的加工能力。

**(4) 需求满足约束：**
```
SUM_{t in T} x_it + d_i * u_i >= d_i,  对所有 i in N
```
说明：确保每个订单要么完全满足，要么标记为未满足。

**(4.1) 欠交定义：**
```
d_i * u_i >= b_iT,  对所有 i in N
```
说明：管理延迟需求，确保正确应用惩罚。

**(5) 生产产能约束：**
```
SUM_{i in N} s_i^X * x_it + SUM_{g in G} s_g^Y * y_gt <= C_t,  对所有 t in T
```
说明：限制每个周期的总生产量在产能范围内。

**(6) 换型需求约束（单订单）：**
```
h_ig * s_i^X * x_it - C_t * y_gt - C_t * lambda_gt <= 0,  对所有 i in N, g in G, t in T
```

**(6.1) 换型需求约束（聚合）：**
```
SUM_{i in N} h_ig * s_i^X * x_it - C_t * y_gt - C_t * lambda_gt <= 0,  对所有 g in G, t in T
```
说明：约束(6)-(10)管理换型结转，确保换型可从一个周期延续到下一周期。

**(7) 单一结转约束：**
```
SUM_{g in G} lambda_gt <= 1,  对所有 t in T
```
说明：每个周期最多只能有一个订单族的换型结转。

**(8) 结转可行性约束：**
```
y_{g,t-1} + lambda_{g,t-1} - lambda_gt >= 0,  对所有 g in G, t in T
```

**(9) 结转排他性约束：**
```
lambda_gt + lambda_{g,t-1} + y_gt - SUM_{g' in G, g' != g} y_{g',t} <= 2,  对所有 g in G, t in T
```

**(10) 初始条件（换型）：**
```
y_g0 = 0, lambda_g0 = 0,  对所有 g in G
```

**(11) 初始条件（库存）：**
```
I_f0 = 0,  对所有 f in F
```

**(12) 非负约束（生产）：**
```
x_it >= 0,  对所有 i in N, t in T
```

**(13) 时间窗口约束：**
```
SUM_{t < e_i} x_it = 0,  对所有 i in N
```
说明：在就绪时间之前不能生产。

**(14) 欠交跟踪：**
```
d_i - SUM_{t' <= t} x_{it'} = b_it,  对所有 i in N, t in T, t >= l_i
```

**(15) 欠交非负：**
```
b_it >= 0,  对所有 i in N, l_i <= t <= T
```

**(16) 库存/加工非负：**
```
I_ft, P_ft >= 0,  对所有 f in F, t in T
```

**(17) 二元变量约束：**
```
y_gt, lambda_gt in {0, 1},  对所有 g in G, t in T
```

**(18) 未满足需求二元变量：**
```
u_i in {0, 1},  对所有 i in N
```

---

## 3. 求解算法

### 3.1 三阶段分解算法（RR/PP-GCB）

该算法采用结构化方法，结合启发式和精确方法。首先，将具有相同订单族和物料流的订单合并为较大的聚合订单，以降低问题维度。

#### 第一阶段：确定换型结构

- 固定所有结转变量 lambda_gt = 0
- 将生产产能 C_t 放大到足够大的值（如10倍）
- 求解简化模型，获得初始换型决策 y_gt*

**目的：** 在无产能限制下确定初步的换型结构。

#### 第二阶段：换型结转优化

利用第一阶段获得的换型配置 y_gt*，求解以下优化问题以最大化换型结转次数：

```
max  SUM_{g in G, t in T} lambda_gt

约束条件：
    SUM_{g in G} lambda_gt <= 1,  对所有 t in T
    2 * lambda_gt <= y_{g,t-1} + y_gt,  对所有 g in G, t in T
    lambda_{g,t-1} + lambda_gt <= 2 - SUM_{g' in G, g' != g} y_{g',t-1} / |G|,  对所有 g in G, t in T
    lambda_gt in {0, 1}
```

**目的：** 通过换型连续性最大化运营效率。

#### 第三阶段：最终生产计划

- 对所有 lambda_gt = 1 的情况，设置相应的 y_gt = 0
- 固定 lambda_gt 和修改后的 y_gt
- 使用原始产能约束求解完整模型

**目的：** 计算最终生产量 x_it、库存 I_ft 和未满足需求指标 u_i。

### 3.2 其他算法

| 算法 | 说明 | 特点 |
|------|------|------|
| **RF** (Relax-and-Fix) | 滚动时域启发式 | 快速，提供良好初始解 |
| **RFO** (RF + Fix-and-Optimize) | 两阶段方法 | 通过局部优化提高解质量 |
| **CPLEX直接求解** | 完整MIP求解器 | 小规模算例可获最优解 |

---

## 4. 数值实验设计

### 4.1 测试算例生成

使用 **LS-NTGF-Data-Cap** 工具生成测试算例，基础参数如下：

| 参数 | 值 | 说明 |
|------|-----|------|
| T | 30 | 计划周期数 |
| F | 5 | 下游工序(Flow)数 |
| G | 5 | 订单族(Group)数 |
| zoom | 60 | 产能缩放因子 |

### 4.2 算例规模

| 规模级别 | 订单数 N | 算例数量 | 合计 |
|----------|----------|----------|------|
| 小 | 100 | 10 | 10 |
| 中 | 200 | 10 | 10 |
| 大 | 300 | 10 | 10 |

**基础算例：** 30个算例（Medium难度）

### 4.3 难度级别

| 难度 | capacity_utilization | demand_cv | peak_multiplier |
|------|---------------------|-----------|-----------------|
| Easy（简单） | 0.55 | 0.15 | 1.5 |
| Medium（中等） | 0.70 | 0.25 | 2.0 |
| Hard（困难） | 0.85 | 0.35 | 2.5 |

**扩展算例：** 3种规模 x 3种难度 x 10算例 = 90个算例

### 4.4 实验一：算法有效性验证

**目的：** 验证PP-GCB三阶段算法能有效求解问题。

**方法：**
1. 对30个基础算例（Medium难度）运行RR算法
2. 记录各阶段的目标值、运行时间和优化Gap

**评价指标：**
- 求解成功率
- 各阶段目标值收敛情况
- 总运行时间

### 4.5 实验二：算法对比分析

**目的：** 比较四种求解方法的性能。

| 方法 | 说明 | 时间限制 |
|------|------|----------|
| CPLEX | 直接MIP求解 | 300秒 |
| RF | Relax-and-Fix | 60秒/子问题 |
| RFO | RF + Fix-and-Optimize | 30秒/子问题 |
| RR | PP-GCB三阶段分解 | 60秒/阶段 |

**评价指标：**
- 目标函数值（总成本）
- 与CPLEX最优解的Gap
- 计算时间
- 可扩展性（性能随问题规模的变化）

### 4.6 实验三：参数敏感性分析

#### 4.6.1 惩罚系数敏感性

| u_penalty（未满足惩罚） | b_penalty（欠交惩罚） |
|------------------------|----------------------|
| 5,000 | 50 |
| 10,000 | 100 |
| 20,000 | 200 |

**测试算例：** N=200，10个算例，使用RR算法

#### 4.6.2 问题难度敏感性

在Easy/Medium/Hard三种难度级别下测试RR算法。

**测试算例：** N=200，每种难度10个算例

#### 4.6.3 订单合并阈值敏感性

| 阈值（Threshold） | 说明 |
|-------------------|------|
| 500 | 激进合并 |
| 1,000 | 默认值 |
| 2,000 | 保守合并 |
| 无合并 | 禁用合并 |

**测试算例：** N=300，10个算例，使用RR算法

---

## 5. 实验工具

### 5.1 工具概览

| 工具 | 用途 | 路径 |
|------|------|------|
| **LS-NTGF-Data-Cap** | 测试算例生成 | D:/YM-Code/LS-NTGF-Data-Cap/ |
| **LS-NTGF-All** | 求解器后端（RF/RFO/RR + CPLEX） | D:/YM-Code/LS-NTGF-All/ |
| **LS-NTGF-GUI** | 图形用户界面 | D:/YM-Code/LS-NTGF-GUI/ |

### 5.2 算例生成器（LS-NTGF-Data-Cap）

**配置示例**（`src/main.cpp`）：

```cpp
vector<int> N_list = { 100, 200, 300 };
vector<int> T_list = { 30 };
vector<int> F_list = { 5 };
vector<int> G_list = { 5 };
int case_size = 10;
double capacity_utilization = 0.70;  // Medium难度
```

**输出格式：** CSV文件，保存在 `data/` 目录

**命名规则：** `{zoom}_N{N}_T{T}_F{F}_G{G}_{difficulty}_{timestamp}.csv`

### 5.3 求解器后端（LS-NTGF-All）

**命令行用法：**

```bash
LS-NTGF-All --algo=RR -f <data.csv> -o <output_dir> -l <log_file> \
            -t <time_limit> --u-penalty <val> --b-penalty <val> \
            --threshold <threshold> --cplex-workdir <dir> \
            --cplex-workmem <mem> --cplex-threads <threads>
```

**算法选项：**
- `--algo=RF`：Relax-and-Fix算法
- `--algo=RFO`：RF + Fix-and-Optimize算法
- `--algo=RR`：PP-GCB三阶段分解算法

### 5.4 图形界面（LS-NTGF-GUI）

**使用流程：**
1. 选择测试算例文件（浏览按钮）
2. 配置算法和参数
3. 点击"运行"开始优化
4. 实时监控进度和日志
5. 在表格中查看结果
6. 如需要可导出日志

**输出位置：**
- 结果文件：`results/solution_<algo>_<timestamp>/`
- 日志文件：`logs/log_<algo>_<timestamp>.log`

---

## 6. 结果分析模板

### 6.1 算法性能对比表

**表1：不同规模下的算法性能对比**

| N | 方法 | 平均目标值 | 平均Gap(%) | 平均时间(s) | 求解成功率 |
|---|------|-----------|------------|-------------|------------|
| 100 | CPLEX | - | - | - | - |
| 100 | RF | - | - | - | - |
| 100 | RFO | - | - | - | - |
| 100 | RR | - | - | - | - |
| 200 | CPLEX | - | - | - | - |
| 200 | RF | - | - | - | - |
| 200 | RFO | - | - | - | - |
| 200 | RR | - | - | - | - |
| 300 | CPLEX | - | - | - | - |
| 300 | RF | - | - | - | - |
| 300 | RFO | - | - | - | - |
| 300 | RR | - | - | - | - |

### 6.2 RR算法各阶段详情

**表2：三阶段分解算法各阶段结果**

| 阶段 | 目标 | 平均目标值 | 平均时间(s) |
|------|------|-----------|-------------|
| 第一阶段 | 确定换型结构 y* | - | - |
| 第二阶段 | 优化换型结转 lambda* | - | - |
| 第三阶段 | 最终生产计划 | - | - |

### 6.3 参数敏感性分析结果

**表3：惩罚系数敏感性分析**

| u_penalty | b_penalty | 平均目标值 | 未满足需求率 |
|-----------|-----------|-----------|--------------|
| 5,000 | 50 | - | - |
| 10,000 | 100 | - | - |
| 20,000 | 200 | - | - |

### 6.4 建议图表

1. **算法性能对比柱状图**：不同规模下各算法的目标值和计算时间
2. **可扩展性曲线**：计算时间随订单数N增长的趋势
3. **敏感性分析图**：参数变化对目标值的影响
4. **三阶段收敛图**：RR算法各阶段目标值的收敛过程

---

## 7. 预期结果

### 7.1 算法有效性
- RR算法能够为所有测试算例获得可行解
- 三阶段分解在各阶段显示出明确的目标值改进

### 7.2 算法对比
- CPLEX对小规模算例（N<=100）提供最优解
- RR在大规模算例上的解质量优于RF/RFO
- RF提供最快的计算速度
- RFO在质量和速度之间取得平衡

### 7.3 可扩展性
- 启发式算法的计算时间随问题规模适度增长
- CPLEX对大规模算例（N>=300）变得难以求解

### 7.4 参数敏感性
- 更高的惩罚系数减少未满足需求但增加总成本
- 订单合并显著减少计算时间，对解质量影响较小

---

## 8. 实验时间估算

| 实验 | 算例数 | 算法数 | 预计时间 |
|------|--------|--------|----------|
| 实验一（有效性验证） | 30 | 1 (RR) | 约1小时 |
| 实验二（算法对比） | 30 | 4 | 约4小时 |
| 实验三（敏感性分析） | 70 | 1 (RR) | 约2小时 |

**总计：** 约7-8小时（可通过批量处理并行执行）

---

## 9. 注意事项

1. **CPLEX限制**：大规模算例（N>=300）可能无法在时间限制内求得最优解，记录为"未求得"
2. **随机种子**：确保每次生成算例使用不同的随机种子，以保证统计有效性
3. **结果备份**：及时备份实验结果到独立目录，防止数据丢失
4. **异常处理**：记录求解失败的算例，分析失败原因
5. **环境一致性**：确保所有实验在相同的硬件和软件环境下进行

---

## 参考文献

1. Verdejo et al. (2009) - 连续镀锌线排序问题与Tabu Search
2. Martinez-de-Pison et al. (2011) - 基于AI和遗传算法的退火周期优化
3. Gao et al. (2018) - 并行连续镀锌线的混合MILP分解方法
4. Brahimi et al. (2006) - 生产计划问题的时间窗口扩展
5. Sox and Gao (1999), Haase (1996) - 换型结转的影响研究
6. Dillenberger (1994) - 考虑换型结转的分支定界方法
